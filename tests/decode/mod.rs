fn test_decode<'a, T: serde::ser::Serialize + serde::de::Deserialize<'a> + PartialEq + std::fmt::Debug>(
    expected: T,
    variants: &'a [&'a [u8]],
) {
    let buff = &mut [0u8; 1024 * 100];
    let len = wasm_msgpack::encode::serde::to_array(&expected, buff).unwrap();
    let actual_bytes = &buff[0..len];
    println!("actual_bytes: {:?}", actual_bytes);
    for &x in variants.iter() {
        println!("from_bytes: {:?}", x);
        let v: T = wasm_msgpack::decode::from_slice(x).unwrap();
        assert_eq!(expected, v);
    }
}

#[test]
fn decode_nil() {
    let mut o = Some(true);
    test_decode(o, &[&[0xc3]]);
    o = None;
    test_decode(o, &[&[0xc0]]);
}
#[test]
fn decode_bool() {
    test_decode(true, &[&[0xc3]]);
    test_decode(false, &[&[0xc2]]);
}
#[test]
fn decode_uint() {
    test_decode(1u8, &[&[0x1], &[0xcc, 0x01], &[0xcd, 0x00, 0x01], &[0xce, 0x00, 0x00, 0x00, 0x01]]);
    test_decode(
        127u32,
        &[&[0x7f], &[0xcc, 0x7f], &[0xcd, 0x00, 0x7f], &[0xce, 0x00, 0x00, 0x00, 0x7f]],
    );
    test_decode(256u16, &[&[0xcd, 0x01, 0x00], &[0xce, 0x00, 0x00, 0x01, 0x00]]);
}
#[test]
fn decode_bin() {
    test_decode(
        wasm_msgpack::Bytes::new(&[
            0x31u8, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x30, 0x31,
            0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x30, 0x31,
        ]),
        &[
            &[
                0xbf, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39,
                0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x30, 0x31,
            ],
            &[
                0xc4, 31, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39,
                0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x30, 0x31,
            ],
            &[
                0xd9, 31, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39,
                0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x30, 0x31,
            ],
            &[
                0xc5, 0, 31, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38,
                0x39, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x30, 0x31,
            ],
            &[
                0xda, 0, 31, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38,
                0x39, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x30, 0x31,
            ],
        ],
    );
}
#[cfg(feature = "bin32")]
#[test]
fn decode_bin32() {
    test_decode(
        wasm_msgpack::Bytes::new(&[
            0x31u8, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x30, 0x31,
            0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x30, 0x31,
        ]),
        &[
            &[
                0xc6, 0, 0, 0, 31, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
                0x38, 0x39, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x30, 0x31,
            ],
            &[
                0xdb, 0, 0, 0, 31, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
                0x38, 0x39, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x30, 0x31,
            ],
        ],
    );
}
use serde::{Deserialize, Serialize};
use serde_repr::Deserialize_repr;
#[allow(clippy::enum_variant_names)]
#[derive(Deserialize, Serialize, PartialEq, Eq, Debug)]
enum Test {
    UnitVariant,
    NewTypeVariant(i32),
    TupleVariant(i32, u8),
    StructVariant { a: i32, b: u8 },
}

#[test]
fn decode_enum_unitvariant() {
    test_decode(
        Test::UnitVariant,
        &[&[0xAB, 0x55, 0x6E, 0x69, 0x74, 0x56, 0x61, 0x72, 0x69, 0x61, 0x6E, 0x74]],
    );
}

#[test]
fn decode_enum_newtypevariant() {
    test_decode(
        Test::NewTypeVariant(1),
        &[&[129, 174, 78, 101, 119, 84, 121, 112, 101, 86, 97, 114, 105, 97, 110, 116, 1]],
    );
}

#[test]
fn decode_enum_tuplevariant() {
    test_decode(
        Test::TupleVariant(1, 2),
        &[&[
            0xAC, 0x54, 0x75, 0x70, 0x6C, 0x65, 0x56, 0x61, 0x72, 0x69, 0x61, 0x6E, 0x74, 0x92, 0x01, 0x02,
        ]],
    );
}

#[test]
fn decode_enum_structvariant() {
    test_decode(
        Test::StructVariant { a: 1, b: 2 },
        &[
            // old impl with serialized keys:
            //   &[0xAD, 0x53, 0x74, 0x72, 0x75, 0x63, 0x74, 0x56, 0x61, 0x72, 0x69, 0x61, 0x6E, 0x74, 0x82, 0xA1, 0x61, 0x01, 0xA1, 0x62, 0x02]
            // new impl serializing a tuple:
            &[130, 173, 83, 116, 114, 117, 99, 116, 86, 97, 114, 105, 97, 110, 116, 146, 1, 2],
        ],
    );
    #[derive(Deserialize_repr, Serialize, PartialEq, Eq, Debug)]
    #[repr(u8)]
    enum Test2 {
        Variant1 = 1,
        Variant2 = 2,
    }
    test_decode(Test2::Variant1, &[&[0x01]]);

    // let v: Option<Test> = wasm_msgpack::decode::from_slice(&[
    //     0xA8, 0x56, 0x61, 0x72, 0x69, 0x61, 0x6E, 0x74, 0x33,
    // ])
    // .unwrap();
    // println!("{:?}", v);
}
